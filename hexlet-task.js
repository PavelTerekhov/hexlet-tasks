https://ru.hexlet.io/courses/intro_to_git/lessons/index/theory_unit - Список русскоязычных локальных it-сообществ



// Task 2 
// 1. Создайте константу weight, запишите в неё вашу массу в килограммах.
// 2. Создайте константу с, запишите в неё значение скорости света в вакууме в метрх в секунду: 300000000.
// 3. Вычислите значение энергии вашего тела с помощью знаменитой формулы E = mc2, где m - это ваша масса (weight), а с - это скорость света. Запишите значение в константу CustomElementRegistry.

// @ts-check
/* eslint-disable no-console */

const pi = 3.14; // eslint-disable-line
const weight = 82;
const c = 3 * Math.pow(10, 8);
let energy = 0;
// BEGIN (write your solution here)
  energy = weight * Math.pow(c, 2);
// END

export default energy;
console.info(`Your body energy is ${energy} joules. This is 1 / ${Math.round(576000000000000000000 / energy)} of the yearly world energy consumption. Woah!`);



// Task 3 

// Реализуйте функцию squareOfSum(), которая принимает на вход два числа и возвращает квадрат суммы этих чисел. Для вычисления значения используйте формулу из курса алгебры: a² + 2 * a * b + b².
// Примеры использования:
// squareOfSum(2, 3) // 25
// squareOfSum(1, 10) // 121


// @ts-check

// BEGIN (write your solution here)
function squareOfSum(numberOne, numberTwo) {
    return Math.pow(numberOne, 2) + 2 * numberOne * numberTwo + Math.pow(numberTwo, 2) 
  }
  // END
  squareOfSum(2, 3);
  squareOfSum(1, 10);
  export default squareOfSum;



// Task 4

// finalGrade.js
// Реализуйте функцию finalGrade(), которая вычисляет итоговую оценку студента на основе двух параметров: оценки за экзамен и количества законченных проектов.

// Функция принимает два аргумента:

// exam — оценка за экзамен, число от 0 до 100;
// projects — количество проектов, число от 0 и выше.
// Функция возвращает: число (итоговую оценку).

// Есть четыре возможных итоговых оценки:

// 100, если оценка за экзамен выше 90 или есть больше 10 проектов
// 90, если оценка за экзамен выше 75 и есть как минимум 5 проектов
// 75, если оценка за экзамен выше 50 и есть как минимум 2 проекта
// 0 в любом другом случае
// Вот как должна работать ваша функция:

// пример вызова         // что должна вернуть функция при таком вызове
// finalGrade(100, 12);  // 100
// finalGrade(99, 0);    // 100
// finalGrade(10, 15);   // 100
 
// finalGrade(85, 5);    // 90
 
// finalGrade(55, 3);    // 75
 
// finalGrade(55, 0);    // 0
// finalGrade(20, 2);    // 0


// @ts-check

// BEGIN (write your solution here)
function finalGrade(exam, projects) {
    let result = 0;
    if (exam > 90 && exam <= 100 || projects > 10) {
      result = 100;
    } else if (exam > 75 && projects >= 5) {
      result = 90;
    } else if (exam > 50 && projects >= 2) {
      result = 75;
    } else {
      result = 0;
    }
    return result;
  }
  // END
  
  export default finalGrade;


// Task 5

// Обычно вам нужно избегать ошибок, но в этом упражнении вы будете порождать ошибки. Это поможет вам понять, какие типы ошибок возникают в разных ситуациях, и привыкнуть распознавать их в будущем.

// Вы будете работать в двух файлах — reference.js и type.js. Ваша задача — породить две ошибки внутри специально созданных функций.

// reference.js
// Сделайте так, чтобы код внутри функции reference() порождал ошибку типа ReferenceError.

// Вспомните, что ReferenceError возникает, когда используется несуществующий идентификатор (имя). Например, если ваша функция возвращает значение константы, но такой константы не существует. Или в каком-нибудь выражении (фрагмент кода, который вычисляется в значение, как формула) используется неизвестный идентификатор.

// type.js
// Сделайте так, чтобы код внутри функции type() порождал ошибку типа TypeError.

// Вспомните, что TypeError возникает, когда вы используете неправильный тип. Например, если вы пытаетесь вызвать численную константу как функцию.

// ВАЖНО
// Ошибки должны генерироваться внутри функций reference() и type().



// Syntax error. Неверное использование языка. Часто лишние или недостающие скобки или кавычки. Что делать? Заменить, удалить или добавить символы. Часто проблема в скобках или кавычках: открытые скобки должны быть закрыты, открытые кавычки должны быть закрыты.
// Reference error. Использование несуществующего названия. Что делать? Проверить, существует ли то, на что вы ссылаетесь. Возможно вы использовали ошибочное название или забыли его создать.
// Type error. Использование неверного типа, например попытка вызвать константу числа, как функцию. Что делать? Убедиться, что всё используется верно. Часто проблема в простой путанице: вы создали численную константу и функциональную константу, а потом пытаетесь вызвать число. Вероятно вы собирались вызвать функцию.
// Logic error. (Логическая ошибка) Ваш код выполняет не то, что требуется, но программа запускается и не выдаёт ошибок трёх перечисленных выше типов. Сломана логика. Что делать? Проверить свой код, убедиться, что он выполняет то, что должен.



// Task 6 

// sequenceSum.js
// Допишите (с использованием рекурсивного процесса) функцию sequenceSum(), которая находит сумму последовательности целых чисел. Последовательность задается двумя значениями: begin - начало последовательности, end - конец последовательности. Например: begin = 2 и end = 6 дают нам такую последовательность 2, 3, 4, 5, 6. Сумма такой последовательности будет: 20.

// import sequenceSum from './sequenceSum';
 
// sequenceSum(1, 5); // 1 + 2 + 3 + 4 + 5 = 15
// sequenceSum(4, 10); // 4 + 5 + 6 + 7 + 8 + 9 + 10 = 49
// sequenceSum(-3, 2); // (-3) + (-2) + (-1) + 0 + 1 + 2 = -3
// Подсказки
// Последовательность, в которой begin > end, не содержит ни одного числа, т.е. является "пустой". Вычислить сумму чисел такой последовательности не представляется возможным, в этом случае возвращаем NaN
// Сумма чисел последовательности, в которой begin === end, равна begin (или end)
// // NaN (т.к. это "пустая" последовательность)
// sequenceSum(7, 2);
 
// // 0 (т.к. это единственное число, входящее в последовательность)
// sequenceSum(0, 0);
// // 6 (т.к. это единственное число, входящее в последовательность)
// sequenceSum(6, 6);
// В файле sequenceSum.test.js можно посмотреть все варианты параметров, с которыми будет вызвана ваша функция.

// @ts-check

const sequenceSum = (begin, end) => {
    // BEGIN (write your solution here)
    if (begin == 0 && end == 0) {
      return 0;
    } else if (begin == end) {
      return begin;
    } else if (begin > end) {
      return NaN;
    }
    return begin + sequenceSum(begin + 1, end);
    // END
  };
  
  export default sequenceSum;


// Task 7 

// smallestDivisor.js
// Реализуйте тело функции smallestDivisor(), используя итеративный процесс. Функция должна находить наименьший делитель заданного числа. Число, передаваемое в функцию, больше нуля.

// Доп. условие: делитель должен быть больше единицы, за исключением случая, когда аргументом является единица (наименьшим делителем которой является также единица).

// Например, наименьший делитель числа 15 это 3.

// smallestDivisor(15); // 3
// smallestDivisor(17); // 17
// Идея алгоритма:

// Попробуйте разделить число на 2.
// Если число делится без остатка, то это наименьший делитель.
// Если нет, то попробуйте следующий делитель.
// Если ничего не делит число без остатка, то переданное число является простым, так что его наименьший делитель — оно само (не считая 1)
// Подсказки
// Вспомните про оператор % (modulus or остаток от деления) из урока 5. Он вычисляет остаток от деления одного операнда на другой. Например, 11 % 5 это 1, а 10 % 2 это 0.

// Так что если x % y это 0, то y делит x без остатка.


// @ts-check

const smallestDivisor = (num) => {
    // BEGIN (write your solution here)
    const iter = (accum) => {
      if (accum > num / 2) {
        return num;
      }
      if (num % accum === 0) {
        return accum;
      }
      return iter(accum + 1);
    }
    return iter(2);
    }
    
    // END
  
  export default smallestDivisor;



// Task 8

// smallestDivisor.js
// Реализуйте тело функции smallestDivisor(), используя итеративный процесс. Функция должна находить наименьший делитель заданного числа. Число, передаваемое в функцию, больше нуля.

// Доп. условие: делитель должен быть больше единицы, за исключением случая, когда аргументом является единица (наименьшим делителем которой является также единица).

// Например, наименьший делитель числа 15 это 3.

// smallestDivisor(15); // 3
// smallestDivisor(17); // 17
// Идея алгоритма:

// Попробуйте разделить число на 2.
// Если число делится без остатка, то это наименьший делитель.
// Если нет, то попробуйте следующий делитель.
// Если ничего не делит число без остатка, то переданное число является простым, так что его наименьший делитель — оно само (не считая 1)
// Подсказки
// Вспомните про оператор % (modulus or остаток от деления) из урока 5. Он вычисляет остаток от деления одного операнда на другой. Например, 11 % 5 это 1, а 10 % 2 это 0.

// Так что если x % y это 0, то y делит x без остатка.

// @ts-check

const smallestDivisor = (num) => {
    // BEGIN (write your solution here)
    const iter = (accum) => {
      if (accum > num / 2) {
        return num;
      }
      if (num % accum === 0) {
        return accum;
      }
      return iter(accum + 1);
    }
    return iter(2);
    }
    
    // END
  
  
  export default smallestDivisor;


// Task 9 

// solution.js
// Напишите функцию smallestDivisor(). Она должна находить наименьший целый делитель числа. Поведение у функции такое же, как в предыдущем уроке, но реализация (код функции) должна быть другой. На этот раз реализуйте императивный итеративный процесс, что означает:

// не используйте рекурсию
// используйте переменные
// используйте цикл while
// Например, наименьший делитель числа 15 это 3.

// smallestDivisor(15); // 3
// smallestDivisor(17); // 17
 
// smallestDivisor(0); // NaN
// smallestDivisor(-3); // NaN
// Примечания
// Если переданное в smallestDivisor() число меньше единицы, возвращайте NaN._
// Алгоритм
// Идея алгоритма:

// Попробуйте разделить число на 2.
// Если число делится без остатка, то это наименьший делитель.
// Если нет, то попробуйте следующий делитель.
// Если ничего не делит число без остатка, то переданное число является простым, так что его наименьший делитель — оно само (не считая 1)
// Подсказки
// Вспомните про оператор % (modulus or остаток от деления) из урока 5. Он вычисляет остаток от деления одного операнда на другой. Например, 11 % 5 это 1, а 10 % 2 это 0. Так что если x % y это 0, то y делит x без остатка.
  
const smallestDivisor = (num) => {
    // BEGIN (write your solution here)
      let counter = 2;
      if (num === 1) {
        return num;
      } else if (num < 1) {
        return NaN;
      }
      while (num % counter != 0) {
        counter++;
      }
      return counter;
  
  // END
  }
  
  export default smallestDivisor;

// Task 10

// reverse.js
// Реализуйте функцию reverse(), которая переворачивает строку. Например:

// reverse('hello, world!'); // !dlrow ,olleh
// Подсказки
// Для решения этой задачи можно двигаться с конца строки к её началу
// Длина строки str находится так: str.length
// Не забудьте, что индексы в строке начинаются с 0, но длина — это реальная длина. Так что индекс последнего символа на единицу меньше длинны строки

// @ts-check
/* eslint operator-assignment: off */

// BEGIN (write your solution here)
function reverse(str) {
    let result = "";
    for (let i = str.length - 1; i >= 0; i--) {
      
      result += str[i];
    }
    return result;
  }
  // END
  
  export default reverse;



// Task 11

// isPrime.js
// Напишите функцию isPrime(). Она принимает число и возвращает true, если число является простым, и false в ином случае.

// Простое число — целое положительное число, имеющее ровно два различных натуральных делителя — единицу и самого себя. Например, 7 — простое число, потому что делится без остатка только на 1 и на себя. 2017 — другое простое число.

// Используйте цикл for и арифметические шорткаты.

// isPrime(1);     // false
// isPrime(7);     // true
// isPrime(10);    // false
// (Число 1 не считаем простым).

// Подсказки
// Для проверки числа на простоту вам может пригодиться Метод перебора делителей

// @ts-check

// BEGIN (write your solution here)
function isPrime(num) {
    if (num < 2) {
      return false;
    }
    for (let i = 2; i <= num / 2; i++) {
      if (num % i === 0) {
        return false;
      }
    }
    return true;
  }
  // END
  
  export default isPrime;


// Task 12

// test.js
// Проверьте с помощью утверждений (asserts) правильность работы функции factorial(), которая вычисляет факториал переданного числа. Факториал числа x — это произведение всех чисел от 1 до x. Например, факториал числа 4 это 1 * 2 * 3 * 4 = 24.

// Подробнее о факториале можно почитать в википедии.

// Саму функцию в этой практике реализовывать не надо, она уже готова. Вам же сейчас надо дописать тесты для проверки её работы.

// Несколько примеров:

// factorial(0); // 1
// factorial(1); // 1
// factorial(5); // 120
// Вам необходимо добавить минимум три дополнительные проверки (помимо уже существующих в модуле), а именно: протестировать пограничные случаи (вызов с параметрами 0 и 1) и сделать проверку на работу с другими неотрицательными целыми числами. Общепринятого факториала от целых отрицательных чисел не существует.

// Подсказки
// assert(<expression>) проверяет, что результат <expression> является истиной.
// assert.equal(<actual>, <expected>) проверяет, что <actual> и <expected> равны (проверка на нестрогое равенство ==).

// function.js
const functions = {
    right1: function factorial(num) {
      if (num === 0) {
        return 1;
      }
      return num * factorial(num - 1);
    },
  
    wrong1: function factorial(num) {
      if (num === 1) {
        return 1;
      }
      return num * factorial(num - 1);
    },
  
    wrong2: function factorial3(num) {
      if (num === 0) {
        return 1;
      } if (num < 4) {
        return num * factorial3(num - 1);
      }
  
      return num;
    },
  
    wrong3: function factorial4(num) {
      if (num === 0) {
        return 1;
      } if (num === 2) {
        return 2;
      } if (num > 1) {
        return num * factorial4(num - 1);
      }
      return 0;
    },
  };
  
  export default functions[process.env.FUNCTION_VERSION];

  
// test.js
import assert from 'assert';
import factorial from './functions.js';

// Example
assert.equal(factorial(2), 2);
assert.equal(factorial(3), 6);
assert.equal(factorial(0), 1);
assert.equal(factorial(1), 1);
assert.equal(factorial(5), 120);


// BEGIN (write your solution here)

// END



// Task 13

// myMathModule.js
// В файле myMathModule.js:

// Создайте функцию getTriangleArea(), которая принимает два аргумента h и b и вычисляет площадь треугольника по формуле A = 1/2 * h * b, где h — высота, а b — основание треугольника.

// Вычисление площади треугольника

// getTriangleArea(5, 10) === 25;
// getTriangleArea(15, 12) === 90;
// Экспортируйте функцию.

// solution.js
// В файле solution.js:

// Импортируйте функцию getTriangleArea() из модуля myMathModule.
// Создайте функцию, которая принимает аргумент n и возвращает площадь треугольника высотой n и основанием n2/2. Используйте функцию square() (принимает число и возвращает его квадрат).
// Экспортируйте созданную функцию по умолчанию.


// myMathModule.js
// @ts-check

export const getTrianglePerimeter = (a, b, c) => a + b + c;
export const getTriangleArea = (h, b) => { return 1 / 2 * h * b; }


// BEGIN (write your solution here)

export default getTriangleArea;
// END

// solution.js
// @ts-check

import square from './square.js';
import { getTriangleArea } from './myMathModule.js'; export default (n) => getTriangleArea(n, square(n) / 2);



// BEGIN (write your solution here)


// END


// square.js
// @ts-check

export default (num) => num * num;

// Посмотрите, как здесь работает экспорт по умолчанию: мы не создаем константу для функции,
// но вместо этого экспортируем безымянную (анонимную) функцию.
// Это проще и требует меньше кода, но вы не можете использовать эту функцию в этом файле,
// потому что у функции нет имени, по которому её можно вызвать.
// Думайте об этом как о товарах "только для экспорта" ;-)


// Task 14 

// squares.js
// Реализуйте функцию square(), которая возвращает квадрат числа.
// Реализуйте функцию sumOfSquares(), которая возвращает сумму квадратов двух чисел.
// Реализуйте функцию squareSumOfSquares(), которая возвращает квадрат суммы квадратов двух чисел.
// Примеры работы функций:

// square(5); // 25
// square(10); // 100
// sumOfSquares(5, 10); // 125
// sumOfSquares(10, -9); // 181
// squareSumOfSquares(1, 1); // 4
// squareSumOfSquares(2, 3); // 169
// Обратите внимание на то, что самостоятельно вызывать их не надо. Это делает проверяющая система в файле __tests__/squares.tests.js

// Подсказки
// Функция square() может быть использована внутри sumOfSquares()
// Функция sumOfSquares() может быть использована внутри squareSumOfSquares()

// @ts-check

// BEGIN (write your solution here)
function square(numOne) {
    return numOne**2;
  }
  
  function sumOfSquares(numOne, numTwo) {
    return numOne**2 + numTwo**2
  }
  
  const squareSumOfSquares = (numOne, numTwo) => {
    return (numOne ** 2 + numTwo ** 2)**2
  }
  // END
  
  export {
    square,
    sumOfSquares,
    squareSumOfSquares,
  };



// Task 15

// Функции lessThan, greaterThan и isEqual в модуле comparers сравнивают две строки и возвращают true/false.

// Сравнение идет по количеству заглавных символов в строке (больше заглавных — больше строка).

// Специальные символы (например, пробел) не имеют заглавных эквивалентов и в данном задании считаются заглавными.

// Примеры:

// greaterThan('AD', 'ad sd'); // true, сравнение на > (больше)
// greaterThan('AD', '   Ad sd'); // false, сравнение на > (больше)
// lessThan('ghe df', 'dfwe r D'); // true, сравнение на < (меньше)
// isEqual('liSp', 'lisP'); // true
// comparers.js
// Допишите необходимые части функций bigLettersCount и compare для того, чтобы заработали функции lessThan, greaterThan и isEqual.

// Функция compare, принимающая две строки first и second, работает по следующему алгоритму:

// Если в первой строке больше заглавных символов, то возвращается 1.
// Если во второй строке больше заглавных символов, то возвращается -1.
// Иначе возвращается 0.
// Подсказки
// Функция bigLettersCount должна принимать на вход строку str и высчитывать количество заглавных символов в ней.
// Вычисление длины строки: length(str).
// Перевод строки в верхний регистр: toUpperCase(str).
// Проверка на то, что символ в верхнем регистре: toUpperCase(char) === char;


// @ts-check

import { length, toUpperCase } from './strings.js';

const bigLettersCount = (str) => {
  // BEGIN (write your solution here)
  let finalCounter = 0;
  
  for (let i = 0; i < str.length; i++) {
    if (toUpperCase(str[i]) === str[i]) {
      finalCounter++;
    }
  }
  return finalCounter;
  // END
};


const compare = (first, second) => {
  const firstCount = bigLettersCount(first);
  const secondCount = bigLettersCount(second);

  // BEGIN (write your solution here)
  if (firstCount > secondCount) {
    return 1;
  } else if (secondCount > firstCount) {
    return -1;
  } else {
    return 0;
  }  
  // END
};

export const greaterThan = (first, second) => (
  compare(first, second) === 1);

export const lessThan = (first, second) => (
  compare(first, second) === -1);

export const isEqual = (first, second) => (
  compare(first, second) === 0);


// Task 16

// addDigits.js
// Реализуйте и экспортируйте по умолчанию функцию, которая работает следующим образом:

// Дано неотрицательное целое число num. Складывать все входящие в него цифры до тех пор, пока не останется одна цифра.

// Для числа 38 процесс будет выглядеть так:

// 3 + 8 = 11
// 1 + 1 = 2
// Результат: 2

// Примеры
// addDigits(10); // 1
// addDigits(19); // 1
// addDigits(38); // 2
// addDigits(1259); // 8
// Подсказки
// Выделите процесс суммирования цифр в числе в отдельную функцию
// Для преобразования типов используйте функции из урока

// addDigits.js
import { length } from './strings.js';

// BEGIN (write your solution here)
function numberSumm(num) {

  num = String(num);

  let sum = 0;
  for (let i = 0; i < num.length; i++) {
    sum += +num[i];
  }
  if (sum >= 10) {
    return numberSumm(sum);
  } else {
    return sum;
  }
}

export default numberSumm;

// END


//strings.js
/* eslint-disable import/prefer-default-export */
export const length = (str) => str.length;



// Task 17 

// solution.js
// Реализуйте и экспортируйте по умолчанию функцию, которая делает заглавной первую букву каждого слова в предложении.

// Пример
// solution('hello, world!'); // Hello, World!
// Подсказки
// Вычисление длины строки: length(str).
// Перевод строки/буквы в верхний регистр: toUpperCase(str).

// @ts-check

import { length, toUpperCase } from './strings.js';

// BEGIN (write your solution here)
export default (str) => {
  let result = "";
  for (let i = 0; i < length(str); i++) {
    const shouldBeBig = str[i] !== " " && (i === 0 || str[i - 1] === " ");
    result += shouldBeBig ? toUpperCase(str[i]) : str[i];
  }

  return result;
}
// END



// Курс по Git 

Task 7

// code-user/
// Выполните клонирование репозитория:

// # Находясь в той директории, которая загружается автоматически в терминале
// # Первый параметр «откуда», второй — «куда»
// $ git clone repos/git-user code-user
// В репозитории уже есть два файла. Измените их так:

// В hexlet.txt добавьте второй строчкой текст I like to change files
// В index.html замените текст на <h1>С помощью гит можно писать книги</h1>
// Выполните один коммит, содержащий сразу эти два изменения. Во время коммита git попросит установить емейл и имя пользователя. Сделайте это, используя любые вымышленные данные
// Добавьте изменения в основной репозиторий с помощью git push
// Подсказки
// После добавления емейла и имени пользователя нужно повторить коммит, так как предыдущий коммит из-за отсутствия настроек выполнен не был


// # При выполнении задачи состояние репозитория могло измениться.
// # Перед набором команд из списка, обновите упражнение с помощью кнопки Сброс.

// git clone repos/git-user code-user
// cd code-user/
// echo 'I like to change files' >> hexlet.txt
// echo '<h1>С помощью гит можно писать книги</h1>' > index.html
// git add .
// git config --global user.email "you@example.com"
// git config --global user.name "Your Name"
// git commit -m 'fix hexlet.txt and index.html'
// git push

// Если файл был удалён, для востановления используются команды для востановления или изменения коммита

// Changes not staged for commit:
//   (use "git add/rm <file>..." to update what will be committed)
//   (use "git restore <file>..." to discard changes in working directory)
//     deleted:    PEOPLE.md


// Можно удалить всю рабочую директорию целиком и потом без проблем восстановить её. Так мы достигаем важной цели — делаем возможным быстрое восстановление последней версии кода, если изменения, которые мы делали, нас больше не устраивают. Или мы можем закоммитить их, если это нужно:

// rm PEOPLE.md
// # Любое изменение обязательно добавлять в индекс
// git add PEOPLE.md
// git commit -m 'remove PEOPLE.md'

// [main e15afd2] remove PEOPLE.md
// 1 file changed, 1 deletion(-)
// delete mode 100644 PEOPLE.md
// # Теперь этот файл пропал из рабочей директории
// Обратите внимание на важную деталь. Независимо от того, удаляем мы файл, добавляем или меняем, процедура выполнения коммита не меняется. После изменений всегда делается git add, который подготавливает изменение к коммиту (а не добавляет файл!), и после этого выполняется коммит.

// Кстати, у git есть команда git rm, которая объединяет в себе удаление и подготовку к коммиту:

// git rm PEOPLE.md
// # равносильно rm + git add




// По умолчанию git diff показывает изменения только для тех модифицированных файлов, которые ещё не были добавлены в индекс. Подразумевается, что добавленные в индекс файлы смотреть не нужно, ведь мы их уже подготовили к коммиту. В реальности же часто хочется и, более того, нужно увидеть эти изменения. Для этого нужно запустить команду вывода дифа с флагом --staged:

// # Выведет все изменения сделанные в рабочей директории
// # которые были добавлены в индекс
// git diff --staged
// git diff — команда, которую нужно обязательно запускать перед каждым коммитом. Она позволяет проанализировать добавляемые изменения и исправить возможные ошибки. Иногда программисты по ошибке добавляют в коммит то, что туда не должно попасть.



Task 8

// code-user/
// Выполните следующие действия:

// Удалите файл index.html
// Переименуйте файл hexlet.txt в hexlet2.txt
// После каждого действия добавляйте изменения в отслеживание и изучайте вывод команды git diff --staged и git status. Обратите внимание на различия вывода последней команды до добавления изменений в индекс и после.

// Закоммитьте каждое изменение отдельно.

// cd code-user/ # Переходим в директорию code-user
// rm -f index.html
// git add index.html
// git commit -m 'remove index.html'
// mv hexlet.txt hexlet2.txt
// git add hexlet.txt
// git add hexlet2.txt
// git commit -m 'rename hexlet.txt to hexlet2.txt'



// Git Show

// У каждого коммита есть идентификатор (говорят "хеш"), уникальный набор символов. С помощью хеша можно посмотреть все изменения, сделанные в рамках одного коммита:
// Хеши коммитов в git очень длинные, и ими бывает неудобно пользоваться. Поэтому разработчики git добавили возможность указывать только часть хеша. Достаточно взять первые 8 символов и подставить их в ту команду, которая работает с коммитами:
// git show 5120bea3

// Git Blame

// А что если мы не знаем коммита, но нам интересно, кто последним менял конкретную строку в файле? Для этого подойдет команда git blame <путь до файла>. Эта команда выводит файл и рядом с каждой строкой показывает того, кто её менял и в каком коммите.
// git blame INFO.md
// e6f625cf (tirion 2020-09-17 16:14:09 -0400 1) git is awesome!
// 5120bea3 (tirion 2020-09-17 18:04:19 -0400 2) new line

// Git Grep

// Команда git grep ищет совпадение с указанной строкой во всех файлах проекта. Это очень удобная команда для быстрого анализа из терминала. Она удобнее обычного grep, так как знает про игнорирование и не смотрит в директорию .git, а ещё умеет искать по истории:
// git grep line
// INFO.md:new line
// # Флаг i позволяет искать без учета регистра
// git grep -i hexlet
// README.md:Hello, Hexlet! How are you?
// # Поиск в конкретном коммите
// git grep Hexlet 5120bea3
// # Поиск по всей истории
// # rev-list возвращает список хешей коммитов
// git grep Hexlet $(git rev-list --all)


// Неотслеживаемые файлы

// Самая простая ситуация. Вы добавили новые файлы в репозиторий (или сгенерировали их как-то) и поняли, что они вам не нужны. В этом случае можно выполнить очистку:
// mkdir one
// touch two
// git status
// On branch main
// Your branch is up to date with 'origin/main'.
// # Пустые директории в git не добавляются в принципе.
// # Физически директория one находится в рабочей директории,
// # но её нет в git, и он её игнорирует
// Untracked files:
//   (use "git add <file>..." to include in what will be committed)
//     two
// # Выполняем очистку
// # -f – force, -d – directory
// git clean -fd
// Removing one/
// Removing two



// Изменения, подготовленные к коммиту

// С файлами, подготовленными к коммиту, можно поступить по-разному. Первый вариант — отменить изменения совсем, второй — отменить только индексацию, не изменяя файлы в рабочей директории. Второе полезно в том случае, если изменения нам нужны, но мы не хотим их коммитить сейчас.
// echo 'new text' > INFO.md
// git add INFO.md
// git status
// On branch main
// Your branch is up to date with 'origin/main'.
// Changes to be committed:
//   (use "git restore --staged <file>..." to unstage)
//     modified:   INFO.md
// И здесь снова помогает Git. При выводе статуса он показывает нужную нам команду для перевода изменений в рабочую директорию:
// git restore --staged INFO.md
// git status
// On branch main
// Your branch is up to date with 'origin/main'.
// Changes not staged for commit:
//   (use "git add <file>..." to update what will be committed)
//   (use "git restore <file>..." to discard changes in working directory)
//     modified:   INFO.md
// Теперь, если нужно, можно выполнить git restore и окончательно отменить изменения в выбранных файлах.


Task 9

// code-user/
// Отмените все изменения, сделанные в рабочей директории и индексе. В результате должен получиться такой вывод:
// $ git status
// nothing to commit, working tree clean

// cd code-user/ # Переходим в директорию code-user
// git restore hexlet.txt
// git restore --staged index.md index.html
// git restore index.html
// git clean -fd


Отмена коммитов

// Git revert

// Фактически она сводится к созданию ещё одного коммита, который выполняет изменения противоположные тому коммиту, который отменяется. Руками создавать подобный коммит довольно сложно, поэтому в git добавили команду, автоматизирующую откат. Эта команда называется git revert:
// # Этой команде нужен идентификатор коммита
// # Это коммит, которым мы удалили файл PEOPLE.md
// git revert aa600a43cb164408e4ad87d216bc679d097f1a6c
// # После этой команды откроется редактор, ожидающий ввода описания коммита
// # Обычно сообщение revert не меняют, поэтому достаточно просто закрыть редактор
// [main 65a8ef7] Revert "remove PEOPLE.md"
//  1 file changed, 1 insertion(+)
//  create mode 100644 PEOPLE.md
// # В проект вернулся файл PEOPLE.md

// git log -p

// commit 65a8ef7fd56c7356dcee35c2d05b4400f4467ca8
// Author: tirion <tirion@got.com>
// Date:   Sat Sep 26 15:32:46 2020 -0400

//     Revert "remove PEOPLE.md"

//     This reverts commit aa600a43cb164408e4ad87d216bc679d097f1a6c.

// diff --git a/PEOPLE.md b/PEOPLE.md
// new file mode 100644
// index 0000000..4b34ba8
// --- /dev/null
// +++ b/PEOPLE.md
// @@ -0,0 +1 @@
// +Haskell Curry
// Команда revert может "отменять" не только последний коммит, но и любой другой коммит из истории проекта. Согласитесь, это очень круто. Без системы контроля версий о таком нельзя было и мечтать.


// 3 режима команды git reset: --soft, --mixed(по умолчанию), --hard



// Git reset


// Иногда удалить нужно только что сделанный по ошибке коммит. Конечно, и в этом случае подходит git revert, но так загрязняется история. Если этот коммит сделан был только сейчас и ещё не отправлялся на Github, то лучше сделать так, как будто бы этого коммита не существовало в принципе.

// Git позволяет удалять коммиты. Это опасная операция, которую нужно делать только в том случае, если речь идет про новые коммиты, которых нет ни у кого, кроме вас.

// Если коммит был отправлен во внешний репозиторий, например, на Github, то менять историю ни в коем случае нельзя, это сломает работу у тех, кто работает с вами над проектом.

// Для удаления коммита используется команда git reset. Делается это так:

// # добавляем новый коммит, который мы сразу же удалим
// echo 'test' >> INFO.md
// git add INFO.md
// git commit -m 'update INFO.md'

// [main 17a77cb] update INFO.md
//  1 file changed, 1 insertion(+)
//  # Важно, что мы не делаем git push

// git reset --hard HEAD~

// HEAD is now at 65a8ef7 Revert "remove PEOPLE.md"

// # Если посмотреть git log, то последнего коммита там больше нет
// git reset — мощная команда, имеющая множество различных флагов и способов работы. С её помощью удаляются или отменяются (без удаления) коммиты, восстанавливаются файлы из истории и так далее. Работа с ней относится к продвинутому использованию git, здесь же мы затрагиваем только самую базу.

// Флаг --hard означает полное удаление. Без него git reset отменит коммит, но не удалит его, а поместит все изменения этого коммита в рабочую директорию, так что с ними можно будет продолжить работать. HEAD~ означает "один коммит от последнего коммита". Если бы мы хотели удалить два последних коммита, то могли бы написать HEAD~2.


// Изменение последнего коммита—

// Крайне часто разработчики делают коммит и сразу же понимают, что забыли добавить часть файлов через git add. Оставшуюся часть изменений можно дослать следующим коммитом либо, если изменения ещё не были отправлены во внешнюю систему, можно добавить изменения в текущий коммит. Для этого во время коммита добавляется флаг --amend:

// В реальности --amend не добавляет изменения в существующий коммит, этот флаг приводит к откату коммита (через reset) и выполнению нового коммита с новыми данными. Поэтому мы и видим ровно один коммит, хотя команда git commit выполнялась два раза (первый раз — когда сделали ошибочный коммит).

// Для того, чтобы не открывался редактор для ввода описания коммита к команде git commit --amend можно добавить опцию --no-edit. В этом случае описание коммита не изменится.


Индексирование по частям


// В Git существует возможность индексировать не только файлы целиком, но и некоторые их части. Например, если вы сделали в файле simplegit.rb два изменения и хотите добавить в индекс только одно из них, добиться этого в Git очень легко. В поле ввода в режиме интерактивного индексирования введите 5 или p (для выполнения patch). Git спросит у вас какие файлы вы хотите добавить в индекс частично; а затем для каждой части выбранных файлов он будет показывать изменения в ней и спрашивать хотите ли вы добавить в индекс эту часть:

// diff --git a/lib/simplegit.rb b/lib/simplegit.rb
// index dd5ecc4..57399e0 100644
// --- a/lib/simplegit.rb
// +++ b/lib/simplegit.rb
// @@ -22,7 +22,7 @@ class SimpleGit
//    end

//    def log(treeish = 'master')
// -    command("git log -n 25 #{treeish}")
// +    command("git log -n 30 #{treeish}")
//    end

//    def blame(path)
// Stage this hunk [y,n,a,d,/,j,J,g,e,?]?
// В этой точке у вас есть множество вариантов дальнейших действий. Если вы введёте ?, Git отобразит, что именно вы можете сделать:

// Добавить в индекс эту часть [y,n,a,d,/,j,J,g,e,?]? ?
// y - добавить в индекс эту часть
// n - не добавлять в индекс эту часть
// a - добавить в индекс эту и все оставшиеся в этом файле части
// d - не добавлять в индекс эту и все оставшиеся в этом файле части
// g - перейти к некоторой части файла (g - показывает список частей и затем выполняет переход, g<N> - перейти к части N)
// / - найти часть, соответствующую регулярному выражению
// j - отложить принятие решения по этой части, перейти к следующей части, решение по которой не принято
// J - отложить принятие решения по этой части, перейти к следующей части
// k - отложить принятие решения по этой части, перейти к предыдущей части, решение по которой не принято
// K - отложить принятие решения по этой части, перейти к предыдущей части
// s - разбить текущую часть на части меньшего размера
// e - вручную отредактировать текущую часть
// ? - отобразить помощь
// Обычно вы будете вводить y или n, если вы хотите индексировать каждую часть по отдельности, но индексация всех частей в некоторых файлах или откладывание решения по индексацию части также может быть полезным. Если вы добавили в индекс одну часть файла, но не добавили другую, состояние вашего рабочего каталога будет подобно приведённому далее:

// What now> 1
//            staged     unstaged path
//   1:    unchanged        +0/-1 TODO
//   2:        +1/-1      nothing index.html
//   3:        +1/-1        +4/-0 lib/simplegit.rb
// Обратите внимание на состояние файла simplegit.rb. Оно говорит вам, что часть строк файла добавлена в индекс, а часть нет. Таким образом, вы частично проиндексировали этот файл. В данный момент вы можете выйти из интерактивного режима команды git add и выполнить git commit, чтобы зафиксировать частично проиндексированные файлы.

// Также вам не обязательно находиться в интерактивном режиме индексирования файлов для выполнения частичной индексации файлов — вы также можете запустить её, используя команды git add -p или git add --patch.

// Более того, вы можете использовать работу с отдельными частями файлов для частичного восстановления файлов с помощью команды reset --patch, для переключения частей файлов с помощью команды checkout --patch и для припрятывания частей файлов с помощью stash save --patch. Мы рассмотрим каждую из этих команд более подробно, когда будем изучать более продвинутые варианты их использования.

Task 10

// Репозиторий для работы находится в директории code-user. Перейти в нее нужно в терминале.

// В файл hexlet.txt было добавлено несколько строк. Используя интерактивный режим git add, разбейте изменения на две части и затем добавьте в индекс одну из них. Выведите на экран состояние изменений подготовленных к коммиту в интерактивном режиме с помощью status. Сделайте коммит, в комментарии которого напишите значение из столбца staged.

// Подсказки
// pwd – текущая директория
// cd – переход в другую директорию
// Чтобы вывести status в интерактивном режиме git add используйте 1 или s.
// После того как мы выбрали файл с помощью patch, он отмечается *. Так как можно выбрать не один файл, а несколько. Подтвердить выбор можно нажатием Enter
// Интерактивное индексирование

// cd code-user/ # Переходим в директорию code-user
// git add -i
// patch
// 1
// # Подтверждаем выбор нажатием Enter
// s
// y
// n
// status
// quit
// git commit -m '+2/-0'



Перемещение по истории

// Git позволяет не только просматривать историю, но и перемещаться по ней, загружая в рабочую директорию состояние кода на момент выполнения любого коммита. Посмотрим:
// # Показывает сокращенный вывод
// git log --oneline
// fc74e2d update README.md
// 65a8ef7 Revert "remove PEOPLE.md"
// 5120bea add new content
// e6f625c add INFO.md
// 273f81c remove NEW.md
// aa600a4 remove PEOPLE.md
// fe9893b add NEW.md
// 3ce3c02 add PEOPLE.md
// 3c5d976 add README.md

// Переключимся на момент, когда был выполнен коммит с сообщением add INFO.md. Для этого используется команда git checkout <хеш коммита>:
// git checkout e6f625c
// Note: switching to 'e6f625c'.
// You are in 'detached HEAD' state. You can look around, make experimental
// changes and commit them, and you can discard any commits you make in this
// state without impacting any branches by switching back to a branch.
// Or undo this operation with:
//   git switch -

// Выполните команду выше (хеш вашего коммита может отличаться) и изучите рабочую директорию. Вы увидите, что пропала часть изменений из-за возврата в прошлое. Сами изменения никуда не делись, и мы снова можем вернуться на последний коммит следующей командой:
// # Что такое main, мы поговорим позже
// git checkout main
// Переключившись в нужный коммит, можно не только изучить содержимое репозитория, но и забрать какие-то изменения, которые были удалены, но снова понадобились для работы. Для этого достаточно их скопировать, переключиться на последний коммит и вставить в нужный файл.

// Где я
// Переключение по коммитам отражается только на содержимом рабочей директории. Больше нигде не видно, где мы находимся. Из-за этого немало программистов, забыв где они находятся, начинают работать и очень удивляются, когда не получается выполнить коммит.

// Самый простой способ узнать место нахождения — вызвать команду git branch. В обычной ситуации, когда мы находимся на последнем коммите, git покажет такой вывод:

// git branch

// # О том, что такое main, мы поговорим позже
// * main
// Но если прямо сейчас загружен коммит из прошлого, то вывод станет таким:

// * (HEAD detached at e6f625c)
//   main
// Такой способ проверки текущего местоположения требует постоянного внимания. Нужно не забывать его использовать и, конечно же, все забывают это делать. Гораздо надежнее и удобнее вывести текущее местоположение прямо в командной строке. Например, так:

// # Если на последнем коммите
// hexlet-git git:(main)

// # Если на коммите из прошлого
// hexlet-git git:(e6f625c)
// Именно так делают большинство профессиональных разработчиков. Как добиться такого вывода? Ответ на этот вопрос зависит от используемого командного интерпретатора. В Bash вывод местоположения происходит благодаря редактированию переменной окружения $PS1, подробнее об этом вы можете почитать по ссылке в дополнительных материалах.


Task 11

// Вы сделали несколько коммитов в репозиторий, и в каком-то из них сохранили файл todo.md со списком задач, а потом удалили этот файл. Загвоздка в том, что в комментарии к коммиту добавление этого файла отражено не было.

// Найдите в истории коммит, в котором был добавлен файл todo.md, и переключитесь на него с помощью git checkout.

// Подсказки
// pwd – текущая директория
// cd – переход в другую директорию
// Если добавить имя файла в конец команды git log, отделив его знаками --, можно увидеть в каких коммитах он изменялся

// cd code-user/ # Переходим в директорию code-user
// git log -p --oneline -- todo.md
// git checkout 7c2fcf8

// # Альтернативный вариант решения использовать опцию --name-status
// # git log --name-status
// # Метка "A" перед файлом, сокращение от "Added"

Task 12

// В репозитории создано 2 дополнительные ветки, помимо master.
// Переключитесь на ветку refactoring и удалите два последних коммита с помощью git reset --hard.
// В ветке working-on-html сделайте коммит, отредактировав файл index.html следующим образом:
// Замените содержимое тега h1 на «Ветки в Git достойны отдельного курса»
// Замените содержимое тега p на «Ветки являются ссылками на определённый коммит.»
// Текст размещайте без кавычек.
// Подсказки
// pwd – текущая директория
// cd – переход в другую директорию
// git switch branch – переключение на ветку с именем branch



// cd code-user/ # Переходим в директорию code-user
// git switch refactoring
// git reset --hard HEAD~2
// git switch working-on-html
// vim index.html # Редактируем и сохраняем файл
// git add index.html
// git commit -m 'fix index.html'


Игнорирование файлов (Gitignore)


// В процессе работы над любым проектом в директории с кодом создаются файлы, которые не являются частью исходного кода. Все эти файлы можно условно разделить на несколько групп:

// Инструментарий

// Служебные файлы, добавляемые операционной системой (.DS_Store в Mac)
// Конфигурационные и временные файлы редакторов (например, .idea, .vscode)
// Временные файлы

// Логи. В них содержится полезная информация для отладки, которая собирается во время запуска и работы приложения
// Кеши. Файлы, которые нужны для ускорения разных процессов
// Артефакты

// Результаты сборки проекта. Например, после компиляции или сборки фронтенда
// Устанавливаемые во время разработки зависимости (например, node_modules, vendor)
// Результаты выполнения тестов (например, информация о покрытии кода тестами)
// Всё это в обычной ситуации не должно попадать в репозиторий. Как правило, эти файлы не несут никакой пользы с точки зрения исходного кода. Они создаются либо автоматически (кеши, логи), либо по запросу (например, скачиваются зависимости или собирается проект). Главная проблема с этими файлами в их постоянном изменении при, как правило, очень больших размерах. Если добавлять их в репозиторий, то практически в каждом коммите, кроме изменений исходного кода, будет и пачка изменений в этих файлах. Читать историю таких коммитов крайне сложно.

// Git позволяет гибко настраивать игнорирование определенных файлов и директорий. Делается это с помощью файла .gitignore, который нужно создать в корне проекта. В этот файл добавляются файлы и директории, которые надо игнорировать. Например:

// # В этом файле можно оставлять комментарии
// # Имя файла .gitignore
// # Файл нужно создать самостоятельно

// # Каждая строчка — это шаблон, по которому происходит игнорирование

// # Игнорируется файл в любой директории проекта
// access.log

// # Игнорируется директория в любой директории проекта
// node_modules

// # Игнорируется каталог в корне рабочей директории
// /coverage

// # Игнорируются все файлы с расширением sqlite3 в директории db,
// # но не игнорируются такие же файлы внутри любого вложенного каталога в db
// # например, /db/something/lala.sqlite3
// /db/*.sqlite3

// # игнорировать все .txt файлы в каталоге doc/
// # на всех уровнях вложенности
// doc/**/*.txt
// Git поддерживает игнорирование файлов, но сам его не настраивает. Для игнорирования файлов и директорий, программист должен создать файл .gitignore в корне проекта, например как тут и добавить его в репозиторий.

// touch .gitignore
// # добавляем в файл правила игнорирования по примеру выше
// git add .gitignore
// git commit -m 'update gitignore'
// Как только .gitignore создан и в него добавлен какой-то файл или директория, игнорирование заработает автоматически. Все новые файлы, попадающие под игнорирование, не отобразятся в выводе команды git status.

// Иногда бывает такое, что программист случайно уже добавил в репозиторий файл, который нужно проигнорировать. В этой ситуации недостаточно обновить правила игнорирования. Дополнительно придется удалить файл или директорию из git с помощью git rm и закоммитить.


Task 13

// Проигнорируйте и удалите из репозитория, если это необходимо, но не удаляйте из рабочей директории, файлы notes.txt и todo.md, а затем сделайте коммит со всеми изменениями.
// Подсказки
// pwd – текущая директория
// cd – переход в другую директорию
// Файл .gitignore уже создан и находится в директории code-user
// У git rm есть опция --cached. Если её использовать, файл будет удалён из репозитория, но не из рабочей директории



// cd code-user/ # Переходим в директорию code-user
// echo 'notes.txt' > .gitignore
// echo 'todo.md' >> .gitignore
// git rm --cached notes.txt
// git commit -m 'remove notes.txt from repo'
// git add hexlet.txt
// git commit -m 'update hexlet.txt'
// git add .gitignore
// git commit -m 'add .gitignore'

// .gitignore

// # BEGIN
// notes.txt
// todo.md
// # END




Stash

// Представьте себе ситуацию. Вы работаете над какой-то важной задачей и исправили довольно много файлов. В этот момент появляется срочная задача — сделать какое-то изменение в исходном коде, не связанное с тем, над чем вы сейчас работаете. Ваши изменения ещё не готовы и они не должны попасть в репозиторий. Что делать?
// В самом простом случае, если ваши изменения не пересекаются с изменениями по срочной задаче, вы можете внести исправления, добавить их в индекс, закоммитить и запушить. Но обычно это неудобно и не всегда возможно. А если изменения нужно делать в тех файлах, с которыми вы работаете прямо сейчас?
// Подобная ситуация у опытных разработчиков встречается регулярно и, к счастью, она легко решается. В git существует набор команд, позволяющий «прятать» изменения в рабочей директории и восстанавливать их при необходимости. Попробуем:

// touch FILE.md
// git add FILE.md
// git status

// On branch main
// Your branch is up to date with 'origin/main'.

// Changes to be committed:
//   (use "git restore --staged <file>..." to unstage)
//     new file:   FILE.md

// # Прячем файлы. После этой команды пропадут все изменённые файлы
// # независимо от того, добавлены они в индекс или нет
// git stash

// Saved working directory and index state WIP on main: e7bb5e5 update README.md

// git status

// On branch main
// Your branch is up to date with 'origin/main'.

// nothing to commit, working tree clean
// git stash не удаляет файлы, они попадают в специальное место внутри директории .git «на сохранение». Эта команда не трогает новые файлы, так как они ещё не являются частью репозитория.

// git stash

// После выполнения всех нужных изменений на чистой рабочей директории можно вернуть спрятанные изменения с помощью команды git stash pop:

// # Восстанавливаем
// git stash pop

// On branch main
// Your branch is up to date with 'origin/main'.

// Changes to be committed:
//   (use "git restore --staged <file>..." to unstage)
//     new file:   FILE.md

// Dropped refs/stash@{0} (b896d4a0126ef4409ede63857e5d996953fe75c5)

// # Проверяем
// git status

// On branch main
// Your branch is up to date with 'origin/main'.

// Changes to be committed:
//   (use "git restore --staged <file>..." to unstage)
//     new file:   FILE.md
// Файлы вернулись в том виде, в котором они попали в стеш (stash).

// Stash в Git работает по принципу стека. Он позволяет сохранить внутрь любое количество изменений и восстановить их в обратном порядке:

// git stash

// # изменяем файлы
// git stash

// # Вернутся последние изменения
// git stash pop

// # Вернутся предпоследние изменения
// git stash pop

Task 14 

// В рабочей директории уже есть изменения, сохраните их с помощью git stash.

// Создайте файл todo.md с любым содержимым
// Добавьте в файл hexlet.txt строку: «stash не трогает новые файлы, которые ещё не добавлены в индекс.»
// Сделайте коммит
// Восстановите сохранённые ранее изменения
// Сделайте еще один коммит, включающий и новые файлы
// Подсказки
// pwd – текущая директория
// cd – переход в другую директорию
// Строку в файл hexlet.txt нужно добавлять без кавычек


// cd code-user/ # Переходим в директорию code-user
// git add . # Так как есть изменения не добавленные в индекс
// git stash
// echo 'Hexlet is awesome!' > todo.md
// echo 'stash не трогает новые файлы, которые ещё не добавлены в индекс.' >> hexlet.txt
// git add .
// git commit -m 'refactoring'
// git stash pop
// git commit -am 'changes from stash'
